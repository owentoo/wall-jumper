<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
  <title>Wall Jumper — Wall-Stick + 24×12 Obstacles</title>
  <style>
    html,body{height:100%;margin:0;background:#101317;color:#fff;font-family:system-ui}
    .wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  </style>
</head>
<body>
<div class="wrap" id="wrap"></div>

<!-- Phaser 3 -->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.min.js"></script>
<script>
(() => {
  const DESIGN_W = 360;
  const DESIGN_H = 640;
  const WALL_PAD = 40;     // inset of the walls from edges (design space)
  const PLAYER_W = 24;     // example player width (match your sprite)
  const PLAYER_H = 34;     // example player height (match your sprite)
  const OB_W = 24;
  const OB_H = 12;

  const config = {
    type: Phaser.AUTO,
    parent: 'wrap',
    backgroundColor: '#101317',
    scale: {
      width: DESIGN_W,
      height: DESIGN_H,
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH
    },
    render: {
      pixelArt: true,      // keep pixel DPI crisp
      antialias: false,
      roundPixels: true
    },
    physics: {
      default: 'arcade',
      arcade: {
        gravity: { y: 1100 },
        debug: false
      }
    },
    scene: { preload, create, update }
  };

  new Phaser.Game(config);

  let player, cursors, leftWall, rightWall, obstacles, spawnTimer = 0, stickSide = null;

  function preload() {
    // Your 24×12 obstacle sprite; keep at 1x scale for perfect DPI
    this.load.image('obstacle', 'obstacle.png');

    // Optional fallback if obstacle.png is missing (we'll draw a 24×12)
    this.load.once(Phaser.Loader.Events.COMPLETE, () => {
      if (!this.textures.exists('obstacle')) {
        const g = this.make.graphics({ x:0, y:0, add:false });
        g.fillStyle(0xff4d4d, 1);
        g.fillRect(0,0,OB_W,OB_H);
        g.generateTexture('obstacle', OB_W, OB_H);
      }
    });

    // Placeholder player if you don’t already have one loaded in your build:
    // Replace with your sprite/sheet and body size below.
    const g = this.make.graphics({x:0,y:0,add:false});
    g.fillStyle(0x7fd1ff,1);
    g.fillRect(0,0,PLAYER_W,PLAYER_H);
    g.generateTexture('playerBox', PLAYER_W, PLAYER_H);
  }

  function create() {
    // Thin invisible wall colliders (immovable, no gravity)
    leftWall  = this.physics.add.staticImage(WALL_PAD, DESIGN_H/2).setSize(2, DESIGN_H).setVisible(false);
    rightWall = this.physics.add.staticImage(DESIGN_W - WALL_PAD, DESIGN_H/2).setSize(2, DESIGN_H).setVisible(false);

    // (Optional) visual wall tiles (if you have your 26×256 assets, add & tile them here)

    // Player
    player = this.physics.add.image(WALL_PAD + PLAYER_W*0.7, DESIGN_H*0.3, 'playerBox');
    player.setCollideWorldBounds(true).setBounce(0).setDragX(0).setFriction(0,0);
    // Tight pixel body to avoid fuzzy collisions
    player.body.setSize(PLAYER_W, PLAYER_H).setOffset(0,0);

    // Obstacles group (immovable, gravity off, pixel-perfect 24×12 hitboxes)
    obstacles = this.physics.add.group({
      allowGravity: false,
      immovable: true
    });

    // Colliders — zero bounce so everything “sticks”
    this.physics.add.collider(player, leftWall,  () => stickToWall('left'));
    this.physics.add.collider(player, rightWall, () => stickToWall('right'));
    this.physics.add.collider(player, obstacles, () => hitObstacle());

    // Input
    cursors = this.input.keyboard.createCursorKeys();
    this.input.on('pointerdown', jump);

    // Camera pixel-perfect
    this.cameras.main.setRoundPixels(true);
  }

  function spawnObstacle(scene) {
    const side = Math.random() < 0.5 ? 'left' : 'right';
    const x = (side === 'left') ? (WALL_PAD + OB_W*0.5) : (DESIGN_W - WALL_PAD - OB_W*0.5);
    const y = Phaser.Math.Between(70, DESIGN_H - 140);

    const ob = obstacles.create(x, y, 'obstacle');
    ob.setScale(1).refreshBody();
    ob.body.setSize(OB_W, OB_H).setOffset(-OB_W/2 + ob.displayOriginX, -OB_H/2 + ob.displayOriginY);
    ob.setImmovable(true);
    ob.body.allowGravity = false;
    ob.setDepth(5);

    // Tiny nudge into the wall so it visually “sticks” and avoids sub-pixel gaps
    if (side === 'left')  ob.x = Math.round(x) + 0.01;
    else                  ob.x = Math.round(x) - 0.01;
  }

  function hitObstacle() {
    // If you need knockback, add it; for “stick” just stop X
    player.setVelocityX(0);
  }

  function stickToWall(side) {
    stickSide = side;
    // Kill any small rebound off wall
    player.setVelocityX(0);
    // Slightly bias the player into the wall to eliminate the micro-gap
    if (side === 'left')  player.x = Math.round(WALL_PAD + PLAYER_W*0.5) + 0.01;
    else                  player.x = Math.round(config.scale.width - WALL_PAD - PLAYER_W*0.5) - 0.01;
  }

  function leaveWall() {
    stickSide = null;
  }

  function jump() {
    // Jump away from the wall with a clear push; stronger horizontal to ensure separation
    const JUMP_VY = -480;
    const PUSH_VX = 280;

    if (stickSide === 'left') {
      player.setVelocity(-PUSH_VX, JUMP_VY);
      leaveWall();
    } else if (stickSide === 'right') {
      player.setVelocity(PUSH_VX, JUMP_VY);
      leaveWall();
    } else if (player.body.onFloor()) {
      // allow ground jump if needed
      player.setVelocityY(JUMP_VY);
    }
  }

  function update(time, delta) {
    // Auto-apply a gentle slide when stuck to a wall
    if (stickSide) {
      // Vertical slide speed
      const SLIDE_VY = 120;
      if (player.body.velocity.y < SLIDE_VY) player.setVelocityY(SLIDE_VY);
      // Clamp X exactly to wall so it “sticks” frame-to-frame
      if (stickSide === 'left') {
        player.x = Math.round(WALL_PAD + PLAYER_W*0.5) + 0.01;
        player.setVelocityX(0);
      } else {
        player.x = Math.round(config.scale.width - WALL_PAD - PLAYER_W*0.5) - 0.01;
        player.setVelocityX(0);
      }
    }

    // Simple keyboard jump (space/up) parity with touch
    if (Phaser.Input.Keyboard.JustDown(cursors.space) || Phaser.Input.Keyboard.JustDown(cursors.up)) {
      jump();
    }

    // Spawn obstacles on a cadence
    spawnTimer += delta;
    if (spawnTimer > 850) { // tweak as desired
      spawnTimer = 0;
      spawnObstacle(this);
    }

    // Keep obstacles locked to their wall (safety against float error)
    obstacles.children.iterate(ob => {
      if (!ob) return;
      // Snap to nearest wall X
      const leftX  = WALL_PAD + OB_W*0.5;
      const rightX = config.scale.width - WALL_PAD - OB_W*0.5;
      ob.x = (Math.abs(ob.x - leftX) < Math.abs(ob.x - rightX)) ? leftX + 0.01 : rightX - 0.01;
      ob.body.updateFromGameObject();
    });
  }
})();
</script>
</body>
</html>
