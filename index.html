<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
  <title>Wall Jumper — Width ≤ 600, Height = Available</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: #101317; color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }
    .shell { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }
    .stage { width: min(100vw, 600px); height: 100%; display: flex; align-items: center; justify-content: center; }
    #game-root canvas { display:block; width:100%; height:100%; image-rendering: pixelated; image-rendering: crisp-edges; touch-action: manipulation; }
  </style>

  <script>
    (function(){
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      function getViewportHeightPx(){
        const vv = window.visualViewport;
        const cands = [ vv && vv.height, window.innerHeight, document.documentElement && document.documentElement.clientHeight ].filter(Boolean);
        return Math.max(1, Math.round(Math.max.apply(null, cands)));
      }
      function sizeStage(){
        const shell = document.querySelector('.shell');
        const stage = document.querySelector('.stage');
        if (!shell || !stage) return;
        if (isMobile) {
          const h = getViewportHeightPx();
          for (const el of [shell, stage]) { el.style.height = h+'px'; el.style.minHeight = h+'px'; el.style.maxHeight = h+'px'; }
        } else {
          shell.style.height = '100vh'; shell.style.minHeight = '100vh'; shell.style.maxHeight = '100vh';
          stage.style.height = '100%'; stage.style.minHeight = '100%'; stage.style.maxHeight = '100%';
        }
        window.dispatchEvent(new Event('resize'));
      }
      function init(){
        sizeStage();
        window.addEventListener('resize', sizeStage);
        window.addEventListener('orientationchange', () => setTimeout(sizeStage, 100));
        if (window.visualViewport){
          window.visualViewport.addEventListener('resize', sizeStage);
          window.visualViewport.addEventListener('scroll', sizeStage);
        }
        setTimeout(sizeStage, 50); setTimeout(sizeStage, 300); setTimeout(sizeStage, 900);
      }
      window.addEventListener('DOMContentLoaded', init);
    })();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>
<body>
  <div class="shell">
    <div class="stage">
      <div id="game-root" style="width:100%;height:100%;"></div>
    </div>
  </div>

<script>
(() => {
  // ------- Tunables -------
  const WORLD_H       = 100000;
  const FALL_MIN      = 300, FALL_MAX = 520, FALL_ACCEL = 6.0;

  // Faster cross jump
  const PUSH_V        = 980;
  const BOOST_V       = 1450;
  const BOOST_MS      = 60;

  // Shared pixel scale
  const PIXEL_SCALE   = 2;

  // Walls
  const WALL_SRC_W    = 26;
  const WALL_DISP_W   = WALL_SRC_W * PIXEL_SCALE;

  // Spikes (24x12 → scaled by PIXEL_SCALE)
  const OB_SRC_W = 24, OB_SRC_H = 12;
  const OB_DISP_W = OB_SRC_W * PIXEL_SCALE, OB_DISP_H = OB_SRC_H * PIXEL_SCALE;
  const SPIKE_INSET_SRC = 2, SPIKE_INSET = SPIKE_INSET_SRC * PIXEL_SCALE;

  // AUDIO: how the music rate scales with speed
  const MUSIC_RATE_MIN = 1.00;
  const MUSIC_RATE_MAX = 1.35; // feel free to raise to 1.5 for wilder tempo
  const MUSIC_VOLUME   = 0.6;

  class Main extends Phaser.Scene {
    constructor(){ super('main'); }
    get W(){ return this.scale.width; }
    get H(){ return this.scale.height; }
    get WALL_GAP(){ return Math.max(120, Math.min(this.W * 0.75, this.W - 60)); }
    get WALL_X(){
      const left  = (this.W - this.WALL_GAP)/2;
      const right = (this.W + this.WALL_GAP)/2;
      return { left, right };
    }

    preload(){
      this.load.spritesheet('ninja', 'ninja_sheet.png', { frameWidth: 24, frameHeight: 34 });
      this.load.image('wallTile', 'wall.png');
      this.load.image('obstacle', 'spike.png');

      // AUDIO: load your song (mp3/ogg/wav)
      this.load.audio('bgm', ['NINJA.mp3']); // change path if needed

      // fallback obstacle if asset missing
      const g = this.make.graphics({add:false});
      g.fillStyle(0xff4d4d,1); g.fillRect(0,0,OB_SRC_W,OB_SRC_H);
      g.generateTexture('obstacle_fallback',OB_SRC_W,OB_SRC_H); g.destroy();
    }

    create(){
      // Animations
      this.anims.create({ key:'slide', frames: this.anims.generateFrameNumbers('ninja', { start:0,  end:11 }), frameRate:18, repeat:-1 });
      this.anims.create({ key:'jump',  frames: this.anims.generateFrameNumbers('ninja', { start:12, end:15 }), frameRate:18, repeat:0  });
      this.anims.create({ key:'land',  frames: [{ key:'ninja', frame:16 }], frameRate:1, repeat:0 });

      // Physics world
      this.physics.world.setBounds(0, 0, this.W, WORLD_H);

      // Visual walls
      this.leftWallVis  = this.add.tileSprite(this.WALL_X.left,  WORLD_H/2, WALL_DISP_W, WORLD_H, 'wallTile')
        .setOrigin(0.5, 0.5).setDepth(0).setTileScale(PIXEL_SCALE, PIXEL_SCALE);
      this.rightWallVis = this.add.tileSprite(this.WALL_X.right, WORLD_H/2, WALL_DISP_W, WORLD_H, 'wallTile')
        .setOrigin(0.5, 0.5).setDepth(0).setFlipX(true).setTileScale(PIXEL_SCALE, PIXEL_SCALE);

      // Physics rails
      this.add.graphics().generateTexture('rail1x1', 1, 1);
      this.leftRail  = this.physics.add.staticImage(this.WALL_X.left,  WORLD_H/2, 'rail1x1').setAlpha(0);
      this.rightRail = this.physics.add.staticImage(this.WALL_X.right, WORLD_H/2, 'rail1x1').setAlpha(0);
      this.leftRail.setDisplaySize(WALL_DISP_W, WORLD_H).refreshBody();
      this.rightRail.setDisplaySize(WALL_DISP_W, WORLD_H).refreshBody();

      // Player
      this.startY = Math.min(700, Math.max(420, this.H * 0.75));
      this.player = this.physics.add.sprite(this.W/2, this.startY, 'ninja', 0).setDepth(2);
      this.player.setScale(PIXEL_SCALE);
      this.player.body.setSize(20, 30, true);
      this.player.body.setOffset((24-20)/2, (34-30)/2);

      // State
      this.physics.world.gravity.y = 0;
      this.fallSpeed = FALL_MIN;
      this.side = 'left';
      this.onWall = true;
      this.alive = true;
      this.playing = false;
      this.deathFall = false;
      this.score = 0; this.best = 0;

      // Camera
      this.cam = this.cameras.main;
      this.cam.setBounds(0,0,this.W,WORLD_H);
      this.cam.startFollow(this.player, true, 1, 1);
      this.cam.setBackgroundColor('#101317');
      this.cam.setRoundPixels(true);

      // HUD
      this.scoreText = this.add.text(this.W/2, 50, '0', {fontSize:'48px', fontStyle:'800', color:'#fff'})
        .setOrigin(0.5).setScrollFactor(0).setDepth(10);
      this.subText   = this.add.text(this.W/2, this.H-34, 'Tap to start', {fontSize:'16px', color:'#9aa3b2'})
        .setOrigin(0.5).setScrollFactor(0).setDepth(10);

      // Obstacles
      this.obstacles = this.physics.add.group({ allowGravity:false, immovable:true });
      this.physics.add.overlap(this.player, this.obstacles, () => { if(this.playing) this.gameOver(); }, null, this);

      // Helpers
      this.updateFacing = () => this.player.setFlipX(this.side === 'right');
      this.playSlide  = () => this.player.anims.play('slide', true);
      this.playJump   = () => this.player.anims.play('jump',  true);

      // AUDIO: create (but don't play yet!)
      this.music = this.sound.add('bgm', { loop: true, volume: MUSIC_VOLUME, rate: MUSIC_RATE_MIN });

      // Rail contact handler (land)
      const contact = (_player, rail) => {
        if (!this.alive || !this.playing) return;
        const which = (rail === this.leftRail) ? 'left' : 'right';
        if (!this.onWall){
          this.onWall = true;
          this.side = which;
          this.player.setVelocity(0, this.fallSpeed);
          this.score += 1; this.scoreText.setText(this.score);
          this.updateFacing();
          this.player.anims.play('land', true);
          this.time.delayedCall(80, () => { if (this.onWall && this.alive) this.playSlide(); });
        } else {
          this.player.setVelocityX(0);
        }
      };
      this.colLeft  = this.physics.add.collider(this.player, this.leftRail,  contact, null, this);
      this.colRight = this.physics.add.collider(this.player, this.rightRail, contact, null, this);

      // Input
      this.input.on('pointerdown', () => this.jump());

      // Spawner
      this.spacingBaseMin = 260;
      this.spacingBaseMax = 340;
      this.nextSpawnY = this.startY + 260;
      this.lastSide = 'right';
      this.lastY = this.startY;
      this.spawnTimer = this.time.addEvent({ delay: 60, loop: true, paused: true, callback: () => this.spawnAhead() });

      // Start overlay & initial placement
      this.showStartOverlay();
      this.snapToWall('left');

      // Resize handling
      this.scale.on('resize', (gameSize) => this.onResize(gameSize));

      // (Optional) stop audio if tab hidden
      this.game.events.on(Phaser.Core.Events.BLUR, () => { if (this.music.isPlaying) this.music.pause(); });
      this.game.events.on(Phaser.Core.Events.FOCUS, () => { if (this.playing && this.music && this.music.isPaused) this.music.resume(); });
    }

    // --- Exact wall placement (no gap) ---
    innerEdgeX(which){
      const rail = (which === 'left') ? this.leftRail : this.rightRail;
      return rail.x + ((which === 'left') ? rail.body.halfWidth : -rail.body.halfWidth);
    }
    playerHalfWidth(){ return this.player?.body ? this.player.body.halfWidth : (this.player.displayWidth * 0.5); }

    snapToWall(which, yOverride = null){
      this.onWall = true;
      this.side = which;

      const edge  = this.innerEdgeX(which);
      const pHalf = this.playerHalfWidth();
      let x = (which === 'left') ? (edge + pHalf) : (edge - pHalf);
      x = Math.round(x);

      if (yOverride !== null) this.player.setY(yOverride);
      this.player.setX(x);
      this.player.setVelocity(0, this.fallSpeed);

      this.updateFacing();
      this.playSlide();
    }

    // Overlays
    showStartOverlay(){
      this.hideGameOverOverlay();
      if (this.overlayStart) this.overlayStart.destroy();

      this.playing = false; this.alive = true; this.deathFall = false;
      this.fallSpeed = FALL_MIN;
      this.obstacles.clear(true,true);
      this.spawnTimer.paused = true;

      this.cam.stopFollow(); this.cam.setBounds(0,0,this.W,WORLD_H);
      this.cam.setScroll(0, Math.max(0, this.startY - this.H*0.5));
      this.cam.startFollow(this.player, true, 1, 1);

      this.subText.setText('Tap to start').setVisible(true);

      this.overlayStart = this.add.container(0,0).setScrollFactor(0).setDepth(1000);
      const dim = this.add.rectangle(this.W/2,this.H/2,this.W,this.H,0x000000,0.45).setInteractive({ useHandCursor:true });
      const title = this.add.text(this.W/2, this.H*0.32, 'WALL JUMPER', {fontSize:'40px', fontStyle:'800', color:'#ffffff'}).setOrigin(0.5);
      const instr = this.add.text(this.W/2, this.H*0.42, 'Tap anywhere to start\nScore on each wall touch\nAvoid the hazards', {fontSize:'18px', color:'#b7c0cf', align:'center'}).setOrigin(0.5);
      this.overlayStart.add([dim,title,instr]);

      // Only play music when the game actually starts (first tap)
      this.input.once('pointerdown', () => {
        if (this.music && !this.music.isPlaying) {
          this.music.setRate(MUSIC_RATE_MIN);
          this.music.play();
        }
        this.startGame();
      }, this);
    }
    hideStartOverlay(){ if (this.overlayStart){ this.overlayStart.destroy(); this.overlayStart = null; } }
    hideGameOverOverlay(){ if (this.overlayGameOver){ this.overlayGameOver.destroy(); this.overlayGameOver = null; } }

    showGameOverOverlay(){
      this.hideStartOverlay();
      if (this.overlayGameOver) this.overlayGameOver.destroy();

      this.playing = false; this.spawnTimer.paused = true;

      // stop music on game over
      if (this.music && this.music.isPlaying) this.music.stop();

      this.overlayGameOver = this.add.container(0,0).setScrollFactor(0).setDepth(1000);
      const dim = this.add.rectangle(this.W/2,this.H/2,this.W,this.H,0x000000,0.45).setInteractive({ useHandCursor:true });
      const title = this.add.text(this.W/2, this.H*0.32, 'GAME OVER', {fontSize:'40px', fontStyle:'800', color:'#ffffff'}).setOrigin(0.5);
      const stats = this.add.text(this.W/2, this.H*0.42, `Score ${this.score} • Best ${this.best}`, {fontSize:'18px', color:'#b7c0cf'}).setOrigin(0.5);
      const tip = this.add.text(this.W/2, this.H*0.47, 'Tap anywhere to restart', {fontSize:'16px', color:'#9aa3b2'}).setOrigin(0.5);
      this.overlayGameOver.add([dim,title,stats,tip]);

      this.input.once('pointerdown', () => this.restart(), this);
    }

    // Flow
    startGame(){
      this.hideStartOverlay();
      if (this.colLeft)  this.colLeft.active = true;
      if (this.colRight) this.colRight.active = true;

      this.score = 0; this.scoreText.setText('0');
      this.subText.setText('Tap to jump').setVisible(true);
      this.fallSpeed = FALL_MIN;
      this.obstacles.clear(true,true);
      this.player.clearTint();

      this.snapToWall('left', this.startY);

      this.nextSpawnY = this.startY + 260;
      this.lastSide = 'right';
      this.lastY = this.startY;

      this.alive = true;
      this.deathFall = false;
      this.playing = true;

      this.cam.rotation = 0;
      this.cam.setBounds(0,0,this.W,WORLD_H);
      this.cam.startFollow(this.player, true, 1, 1);

      this.spawnTimer.paused = false;
    }

    restart(){ this.hideGameOverOverlay(); this.startGame(); }

    // Jump
    jump(){
      if (!this.playing) return;
      if (!this.alive){ this.restart(); return; }
      if (!this.onWall) return;

      const dir = (this.side==='left') ? 1 : -1;
      this.player.setVelocity(dir*BOOST_V, this.fallSpeed);
      this.onWall = false;
      this.subText.setVisible(false);

      this.playJump();
      this.time.delayedCall(BOOST_MS, () => {
        if (!this.onWall && this.alive){ this.player.setVelocity(dir*PUSH_V, this.fallSpeed); }
      });
    }

    getCurrentSpacing(){
      const t = Phaser.Math.Clamp((this.fallSpeed - FALL_MIN)/(FALL_MAX - FALL_MIN), 0, 1);
      const min = Phaser.Math.Linear(this.spacingBaseMin, this.spacingBaseMin + 70, t);
      const max = Phaser.Math.Linear(this.spacingBaseMax, this.spacingBaseMax + 110, t);
      return { min, max };
    }

    // Spawn spikes: stick to wall, flip left, inset
    spawnAhead(){
      if (!this.playing || !this.alive) return;
      const bufferAhead = 1000;
      const camY = this.player.y;
      const { min:curMin, max:curMax } = this.getCurrentSpacing();

      while (this.nextSpawnY < camY + bufferAhead) {
        let side = (Math.random() < 0.8) ? ((this.lastSide === 'left') ? 'right' : 'left') : this.lastSide;
        const y = Math.max(this.nextSpawnY, this.lastY + Phaser.Math.Between(curMin|0, curMax|0));

        const texKey = this.textures.exists('obstacle') ? 'obstacle' : 'obstacle_fallback';
        const ob = this.obstacles.create(0, y, texKey).setDepth(1);
        ob.setScale(PIXEL_SCALE);
        ob.body.setSize(OB_DISP_W - 2, OB_DISP_H, true);

        ob.setData('side', side);
        ob.setFlipX(side === 'left');

        const edge = this.innerEdgeX(side);
        const half = OB_DISP_W * 0.5;
        const targetX = (side === 'left') ? Math.round(edge + half - SPIKE_INSET)
                                          : Math.round(edge - half + SPIKE_INSET);
        ob.x = targetX;

        ob.body.allowGravity = false;
        ob.setImmovable(true);
        ob.setVelocity(0, 0);

        this.lastY = y;
        this.lastSide = side;
        this.nextSpawnY = y + Phaser.Math.Between(curMin|0, curMax|0);
        if (Math.random() < 0.12) this.nextSpawnY += Phaser.Math.Between(40, 80);
      }

      const topCull = this.cameras.main.scrollY - 200;
      this.obstacles.children.each(o => { if (o.active && o.y < topCull) o.destroy(); }, this);
    }

    update(_time, dt){
      if (this.alive){
        this.fallSpeed = Math.min(FALL_MAX, this.fallSpeed + FALL_ACCEL * (dt/1000));
        if (this.player.body) this.player.setVelocityY(this.fallSpeed);
      } else if (this.deathFall){
        if (this.player.body) this.player.setVelocity(0, 900);
        const bottomThreshold = this.cam.scrollY + this.H + 120;
        if (!this.overlayGameOver && this.player.y > bottomThreshold){
          this.deathFall = false;
          this.showGameOverOverlay();
        }
      }
      if (this.playing && this.alive && this.player.y > WORLD_H - 200){ this.gameOver(); }

      // Glue spikes to wall every frame
      this.obstacles.children.iterate(ob => {
        if (!ob || !ob.active) return;
        const side = ob.getData('side');
        const edge = this.innerEdgeX(side);
        const half = OB_DISP_W * 0.5;
        const targetX = (side === 'left') ? Math.round(edge + half - SPIKE_INSET)
                                          : Math.round(edge - half + SPIKE_INSET);
        if (ob.x !== targetX) { ob.x = targetX; ob.body.updateFromGameObject(); }
        ob.setFlipX(side === 'left');
        ob.setVelocityX(0);
      });

      // AUDIO: ramp music tempo with fall speed
      if (this.music && this.music.isPlaying) {
        const t = Phaser.Math.Clamp((this.fallSpeed - FALL_MIN)/(FALL_MAX - FALL_MIN), 0, 1);
        const rate = Phaser.Math.Linear(MUSIC_RATE_MIN, MUSIC_RATE_MAX, t);
        if (Math.abs(this.music.rate - rate) > 0.005) this.music.setRate(rate);
      }
    }

    gameOver(){
      if (!this.alive) return;
      this.alive = false; this.playing = false;
      this.best = Math.max(this.best, this.score);
      this.player.setTint(0xff4d4d);
      this.spawnTimer.paused = true;
      if (this.colLeft)  this.colLeft.active = false;
      if (this.colRight) this.colRight.active = false;
      this.cam.stopFollow();
      this.onWall = false;
      this.deathFall = true;
      this.player.setVelocity(0, 900);

      // stop music (also handled in showGameOverOverlay, but safe here too)
      if (this.music && this.music.isPlaying) this.music.stop();

      this.showGameOverOverlay();
    }

    onResize(gameSize){
      this.physics.world.setBounds(0, 0, gameSize.width, WORLD_H);
      this.cam.setBounds(0, 0, gameSize.width, WORLD_H);

      this.leftRail.setPosition(this.WALL_X.left,  WORLD_H/2).setDisplaySize(WALL_DISP_W, WORLD_H).refreshBody();
      this.rightRail.setPosition(this.WALL_X.right, WORLD_H/2).setDisplaySize(WALL_DISP_W, WORLD_H).refreshBody();

      this.leftWallVis.setPosition(this.WALL_X.left, WORLD_H/2).setSize(WALL_DISP_W, WORLD_H).setTileScale(PIXEL_SCALE, PIXEL_SCALE);
      this.rightWallVis.setPosition(this.WALL_X.right, WORLD_H/2).setSize(WALL_DISP_W, WORLD_H).setTileScale(PIXEL_SCALE, PIXEL_SCALE);

      if (this.onWall) this.snapToWall(this.side);

      this.scoreText.setPosition(this.W/2, 50);
      this.subText.setPosition(this.W/2, this.H - 34);
    }
  }

  const game = new Phaser.Game({
    type: Phaser.AUTO,
    parent: 'game-root',
    backgroundColor: '#101317',
    physics: { default: 'arcade', arcade:{ gravity:{y:0}, debug:false } },
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
    render: {
      pixelArt: true, antialias: false, roundPixels: true,
      resolution: Math.max(1, Math.min(window.devicePixelRatio || 1, 2))
    },
    scene: [Main]
  });

  const stageEl = document.querySelector('.stage');
  new ResizeObserver(() => { window.dispatchEvent(new Event('resize')); }).observe(stageEl);
})();
</script>
</body>
</html>
